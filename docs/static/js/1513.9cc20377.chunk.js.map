{"version":3,"file":"static/js/1513.9cc20377.chunk.js","mappings":";gJAUA,MAAMA,EAAO,YAeb,GACEA,OACA,UAAMC,CAAMC,GACV,MAAMC,EAAYC,MACZ,UAAEC,GAAcF,GAChB,WAAEG,EAAU,IAAEC,EAAG,OAAEC,EAAM,uBAAEC,GAA2BJ,GACtD,QAAEK,EAAO,gBAAEC,GAAoBT,EAC/BU,EAAOP,EAAUQ,cAGvB,IAAIC,EACAC,EACAC,EACAC,EACAC,QA3ByBC,eAAgBhB,GAC/C,IAAIiB,EACJ,MAAMC,EAAOlB,EAAUmB,UAAUC,KAAK,QACtC,IACEH,QAA0B,QAAO,KAADI,OAAaH,EAAI,OACnD,CAAE,MAAOI,GAEPC,QAAQC,KAAK,wBAADH,OAAyBH,EAAI,UAAAG,OAASxB,EAAI,kBACtDoB,QAA0B,8BAC5B,CACAjB,EAAUyB,QAAQC,kBAAkBR,EAAMrB,EAAMoB,EAAkBU,QACpE,CAUUC,CAAyB5B,GAQ/B,IAAI6B,GAAU,EACVC,EAAc,GAGlB,MAAMC,EAAgC7B,EAAU8B,sBAGhD9B,EAAU8B,sBAAwB,WAEhC9B,EAAU+B,oBAAoBC,SAASC,iBAAiB,kBAExD,QAAAC,EAAAC,UAAAC,OAJ6CC,EAAI,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GAKjD,OAAOV,EAA8BW,MAAMzC,KAAMsC,EACnD,EAGA,MAAMI,EAA+BzC,EAAU0C,qBAG/C1C,EAAU0C,qBAAuB,WAAoB,IAAD,IAAAC,EAAAR,UAAAC,OAANC,EAAI,IAAAC,MAAAK,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJP,EAAIO,GAAAT,UAAAS,GAEhD,MAAMC,EAAMJ,EAA6BD,MAAMzC,KAAMsC,GAMrD,OAHAS,EAAiB9C,EAAU+C,uBAGpBF,CACT,EAUA,MAAMG,EAAiBA,CAACC,EAAGC,EAAGC,EAAIC,KAE5BA,KACFD,EAAK,IAAKA,IACPE,OAASD,EACZD,EAAGG,QAAUF,EACbD,EAAGF,GAAKG,EAAS,EACjBD,EAAGD,GAAKE,EAAS,GAInB,MAAMG,EAAOJ,EAAGF,EAAIE,EAAGE,MAAQ,EACzBG,EAAOL,EAAGD,EAAIC,EAAGG,OAAS,EAG1BG,EAAOR,EAAIM,EACXG,EAAOR,EAAIM,EAMjB,IAAIG,EAQJ,OANEA,EALYC,KAAKC,IAAIH,EAAOD,GAIlBN,EAAGG,OAASH,EAAGE,MACjBF,EAAGE,MAAQ,EAAIO,KAAKC,IAAIJ,GAExBC,EAAOP,EAAGG,OAAS,EAAIM,KAAKC,IAAIH,GAAQ,EAI3C,CACLT,EAAGM,EAAOE,EAAOE,EACjBT,EAAGM,EAAOE,EAAOC,EAClB,EASGG,EAAYA,CAACC,EAAMC,KAEvB,MAAMC,EAAYD,EAAKE,aAAa,UAAYH,GAI1CI,EAA2C,EAApCH,EAAKE,aAAa,gBAG/B,OAAOD,EAAYE,EAAO,CAAC,EAQvBC,EAAYC,IAEhB,IAAIC,EAAYpE,EAAI,mBACfoE,IACHA,EAAYtC,SAASuC,cAAc,SACnCD,EAAUE,aAAa,KAAM,mBAC7BxC,SAASyC,qBAAqB,QAAQ,GAAGC,YAAYJ,IAIvDA,EAAUK,YAAeN,EAErB,kFADA,GAIAnE,EAAI,qBACNA,EAAI,mBAAmB0E,MAAMC,QAAUR,EAAK,QAAU,OACxD,EAYIS,EAAWA,CAACC,EAAMC,EAAK/B,EAAGC,EAAG+B,KAEjC,MAAMC,EAAMH,EAAKI,OACXC,EAAK/E,EAAQgF,iBAanB,GAZAD,EAAGnC,EAAIA,EACPmC,EAAGlC,EAAIA,EAGK,QAAR8B,IACFA,EAAME,EAAII,cAAgB,GAI5BJ,EAAIK,YAAYH,EAAIJ,GAGhBC,EAAQ,CACV,MAAMO,EAAUN,EAAIO,QAAQ,GACtBC,EAAQR,EAAIO,QAAQP,EAAII,cAAgB,GAC9CR,EAASC,EAAM,GAAIW,EAAMzC,EAAIuC,EAAQvC,GAAK,GAAIyC,EAAMxC,EAAIsC,EAAQtC,GAAK,EACvE,GAQIyC,EAAeA,CAAC3B,EAAM4B,EAAMzC,EAAI0C,EAAOC,EAAKC,KAChD,MAAMC,EAAOH,EAAM5C,EAAI4C,EAAMxC,MAAQ,EAC/B4C,EAAOJ,EAAM3C,EAAI2C,EAAMvC,OAAS,EAEhC8B,EAAKpC,EAAegD,EAAMC,EAAM9C,EAAIW,EAAUgC,EAAK9B,IACzDc,EAASd,EAAM4B,EAAKM,SAAW,EAAI,MAAOd,EAAGnC,EAAGmC,EAAGlC,GAAG,GAEtD,MAAMiD,EAAMnD,EAAeoC,EAAGnC,EAAGmC,EAAGlC,EAAG2C,EAAO/B,EAAUiC,EAAQ/B,IAChEc,EAASd,EAAM4B,EAAKM,SAAW,MAAQ,EAAGC,EAAIlD,EAAGkD,EAAIjD,GAAG,EAAK,EAgCzDkD,EAAiB,WAAiB,IAAhBC,EAAKlE,UAAAC,OAAA,QAAAkE,IAAAnE,UAAA,GAAAA,UAAA,GAAG,GAE9B,MAAMoE,EAAcvG,EAAUwG,iBAGxBC,EAAazE,SAASC,iBAAiB,iBAE7CL,EAAc,GAGd,IAAK,MAAM8E,KAAaD,EAAY,CAClC,IAAIE,GAAU,EACd,MAAMC,EAAQ,GAGd,IAAK,MAAOC,EAAG7B,IAAQ,CAAC,QAAS,OAAO8B,UAAW,CAEjD,IAAIC,EAAOR,EAAYS,IAAIN,EAAU,KAADvF,OAAO6D,IAGtC+B,EAYHA,EAAO/E,SAASiF,eAAeF,IAX/BA,EAAO/E,SAASiF,eACdP,EAAUQ,WAAW,gBAAgBC,MAAMC,MAAM,KAAKP,IAExDN,EAAYc,IAAIX,EAAU,KAADvF,OAAO6D,GAAO+B,EAAKO,IAC5Cf,EAAYc,IACVX,EAAU,GAADvF,OACN6D,EAAG,OACNhF,EAAUuH,eAAe,CAACR,MAQ9BH,EAAMY,KAAKT,EACb,CAGA,IAAK,IAAIF,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAMY,EAAQb,EAAMC,GACda,EAAU1H,EAAU2H,WAAgB,OAALF,QAAK,IAALA,OAAK,EAALA,EAAOG,YAG5C,IAAK,MAAMC,KAAMH,EACf,GAAIrB,EAAMyB,SAASD,GAAK,CACtBlB,GAAU,EACV,KACF,CAIF,GAAKc,GAAUA,EAAMG,YAMrB,GAAIvB,EAAMyB,SAASL,IAAUd,EAAS,CACpC,MAAMxD,EAAKnD,EAAUuH,eAAe,CAACE,IAGrC7F,EAAY4F,KAAK,CACfzC,KAAM0C,EACNf,YACAR,SAAgB,IAANW,EACVkB,QAAS5E,EAAGF,EACZ+E,QAAS7E,EAAGD,GAEhB,OAhBEwD,EAAUuB,QAiBd,CACF,CACF,EAOMnF,EAAmBuD,IACvB,MAAME,EAAcvG,EAAUwG,iBAK9B,GAFAJ,EAAeC,GAEXzE,EAAYQ,OAEd,IAAK,MAAMwD,KAAQhE,EAAa,CAC9B,MAAM,KACJmD,EACA2B,UAAW1C,EACXkC,SAAUgC,EACVH,QAAStH,EACTuH,QAAStH,GACPkF,EAGEE,EAAMoC,EAAU,QAAU,MAG1B/E,EAAKnD,EAAUuH,eAAe,CAACxC,IACrC5B,EAAGF,EAAIxC,EACP0C,EAAGD,EAAIxC,EACP6F,EAAYc,IAAIrD,EAAK,GAAD7C,OAAK2E,EAAG,OAAO3C,GAGnC,MAAM4C,EAASmC,EAAU,MAAQ,QAG3BC,EAAM5B,EAAYS,IAAIhD,EAAK,GAAD7C,OAAK4E,EAAM,QAGrCC,GAAU,OAAHmC,QAAG,IAAHA,OAAG,EAAHA,EAAKlF,IAAO,OAAHkF,QAAG,IAAHA,OAAG,EAAHA,EAAK9E,OAAQ,EAC7B4C,GAAU,OAAHkC,QAAG,IAAHA,OAAG,EAAHA,EAAKjF,IAAO,OAAHiF,QAAG,IAAHA,OAAG,EAAHA,EAAK7E,QAAS,EAG9B8B,EAAKpC,EAAegD,EAAMC,EAAM9C,EAAIW,EAAUgC,EAAK9B,IACzDc,EAASd,EAAMkE,EAAU,EAAI,MAAO9C,EAAGnC,EAAGmC,EAAGlC,GAAG,GAGhD,MAAMiD,EAAMnD,EACVoC,EAAGnC,EACHmC,EAAGlC,EACHqD,EAAYS,IAAIhD,EAAK,GAAD7C,OAAK4E,EAAM,QAC/BjC,EAAUiC,EAAQ/B,IAEpBc,EAASd,EAAMkE,EAAU,MAAQ,EAAG/B,EAAIlD,EAAGkD,EAAIjD,GAAG,EACpD,CACF,EAOIkF,EAAQA,KACZ,MAAM7B,EAAcvG,EAAUwG,iBAEXxG,EAAUqI,gBACDpG,iBAAiB,KACpCqG,SAAQC,IACf,MAAM3C,EAAO2C,EAAQC,eAAejI,EAAM,aAC1C,GAAIqF,EAAM,CACR,MAAM6C,EAAW7C,EAAKwB,MAAM,KACtBsB,EAAM1I,EAAUuH,eAAe,CAACtH,EAAWwI,EAAS,MACpDE,EAAM3I,EAAUuH,eAAe,CAACtH,EAAWwI,EAAS,MAC1DlC,EAAYc,IAAIkB,EAAS,UAAWE,EAAS,IAC7ClC,EAAYc,IAAIkB,EAAS,QAASE,EAAS,IAC3ClC,EAAYc,IAAIkB,EAAS,WAAYG,GACrCnC,EAAYc,IAAIkB,EAAS,SAAUI,GACnC3I,EAAUQ,aAAY,EACxB,IACA,EAKJ,OAFA4H,IAEO,CACLzI,KAAMG,EAAUyB,QAAQqH,EAAE,GAADzH,OAAIxB,EAAI,UACjCkJ,QAAAA,GAEE,MAAMC,EAAiB9G,SAASuC,cAAc,YACxCwE,EAAK,GAAA5H,OAAMxB,EAAI,oBACrBmJ,EAAeE,UAAS,kDAAA7H,OACe4H,EAAK,4CAE5C7I,EAAI,cAAc+I,OAAOH,EAAeI,QAAQC,WAAU,IAC1DhJ,EAAOD,EAAI,iBAAiB,KACtBH,KAAKqJ,UAAUC,gBAAgB,iBACjCrJ,EAAUsJ,QAAQ,YACpB,GAEJ,EACAC,SAAAA,CAAWC,GAET,MAAMjD,EAAcvG,EAAUwG,iBACxBiD,EAAazJ,EAAUqI,iBACrBqB,MAAOC,EAAG5B,QAAStH,EAAQuH,QAAStH,GAAW8I,EACjDI,EAAO5J,EAAU6J,WAErBC,WAAW,WAAEC,IACXjK,EAAUmB,UAEd,GAAa,cAAT2I,EAAsB,CAExB,GAAIjI,EAAS,OAEb,MAAMqI,EAAcL,EAAEM,OAItB,GAHgBjK,EAAU2H,WAAWqC,EAAYpC,YAGrCE,SAAS2B,GAAa,CAEhC,MAAMS,EAAKlK,EAAUmK,WACnBH,EAAYpC,WACZ,iBAEFhH,EAAYsJ,GAAMF,EAGlB,MAAM7G,EAAKnD,EAAUuH,eAAe,CAAC3G,IAC/BqC,EAAIE,EAAGF,EAAIE,EAAGE,MAAQ,EACtBH,EAAIC,EAAGD,EAAIC,EAAGG,OAAS,EAG7B3B,GAAU,EAGVhB,EAAUP,EAAuB,CAC/BmI,QAAS,WACT6B,KAAM,CACJ9C,GAAI,QAAUtH,EAAUqK,YACxBlF,OAAO,GAADhE,OAAK8B,EAAC,KAAA9B,OAAI+B,EAAC,KAAA/B,OAAI8B,EAAC,KAAA9B,OAAI+B,EAAC,KAAA/B,OAAIV,EAAM,KAAAU,OAAIT,GACzC4J,OAAO,IAADnJ,OAAM4I,EAAWQ,OACvB,eACG3J,EAAU4J,cAA2C,IAA3B5J,EAAU4J,aAEjC5J,EAAU4J,aADVT,EAAW1G,MAEjBoH,KAAM,OACNC,QAASX,EAAWW,QACpB9F,MAAO,yBAKX2B,EAAYc,IAAI1G,EAAS,WAAYwC,EACvC,CAEA,MAAO,CACLxB,SAAS,EAEb,CAEa,WAATiI,GAEFxD,EAAeoD,EAAKmB,iBAIxB,EACAC,SAAAA,CAAWpB,GAET,GAA2B,IAAvB5H,EAAYQ,OAAc,OAE9B,MAAMmE,EAAcvG,EAAUwG,iBACxBqE,EAAO7K,EAAU8K,UAEjB7H,EAAIuG,EAAKuB,QAAUF,EACnB3H,EAAIsG,EAAKwB,QAAUH,EAEzB,IAAKpK,IAAWC,EAAQ,OAExB,MAAMuK,EAAQhI,EAAIxC,EACZyK,EAAQhI,EAAIxC,EAEZkJ,EAAO5J,EAAU6J,UACvB,GAAa,cAATD,GAAwBjI,EAAS,CAGnC,MAAMyD,EAAKpC,EACTC,EACAC,EACAqD,EAAYS,IAAIrG,EAAS,YACzBmD,EAAU,QAASnD,IAErBF,EAAS2E,EAAGnC,EACZvC,EAAS0E,EAAGlC,EAEZ4B,EAASnE,EAAS,EAAGyE,EAAGnC,EAAGmC,EAAGlC,GAAG,GAGjC4B,EAASnE,EAAS,MAAOsC,EAAGC,GAAG,EACjC,MAAO,GAAa,WAAT0G,EAAmB,CAC5B,IAAK,MAAM7E,KAAQ/E,EAAU+C,sBACvBgC,GAAQwB,EAAY4E,IAAIpG,EAAM,aAChC/E,EAAU+B,oBAAoB,CAACgD,IAC/BA,EAAKqG,UAAUC,QAAQC,SAGvB1J,EAAYQ,QArTHmJ,EAACN,EAAOC,KACzB,MAAM3E,EAAcvG,EAAUwG,iBAE9B,IAAK,MAAMZ,KAAQhE,EAAa,CAC9B,MACE8E,UAAW1C,EACXkC,SAAUgC,EACVH,QAAStH,EACTuH,QAAStH,GACPkF,EAEEE,EAAMoC,EAAU,QAAU,MAC1BnC,EAASmC,EAAU,MAAQ,QAG3B/E,EAAK,IAAKoD,EAAYS,IAAIhD,EAAK,GAAD7C,OAAK2E,EAAG,SAC5C3C,EAAGF,EAAIxC,EAASwK,EAChB9H,EAAGD,EAAIxC,EAASwK,EAEhB3E,EAAYc,IAAIrD,EAAK,GAAD7C,OAAK2E,EAAG,OAAO3C,GAGnC,MAAM0C,EAAQU,EAAYS,IAAIhD,EAAK,GAAD7C,OAAK4E,EAAM,QAE7CJ,EAAa3B,EAAM4B,EAAMzC,EAAI0C,EAAOC,EAAKC,EAC3C,GA6RMwF,CAAWN,EAAOC,EAEtB,CACF,EACAM,OAAAA,CAAShC,GAAO,IAADiC,EAAAC,EAEb,MAAMnF,EAAcvG,EAAUwG,iBACxBiD,EAAazJ,EAAUqI,iBACrBqB,MAAOC,GAAMH,EACrB,IAAIQ,EAAcL,EAAEM,OAGpB,GAA4B,cAAxBjK,EAAU6J,UAA2B,OAGzC,MAAMK,EAAKlK,EAAUmK,WAAWH,EAAYpC,WAAY,iBACpDsC,IAAIF,EAAcE,GAGtB,MACMyB,EADU3L,EAAU2H,WAAWqC,EAAYpC,YAClBE,SAAS2B,GAExC,GAAIO,IAAgBpJ,EAGlB,OADAe,GAAU,EACH,CACLiK,MAAM,EACNrD,QAAS,KACT5G,WAIkB,IAADkK,EAArB,IAAKF,EAIH,OAFO,QAAPE,EAAAlL,SAAO,IAAAkL,GAAPA,EAAS5D,SACTtG,GAAU,EACH,CACLiK,MAAM,EACNrD,QAAS,KACT5G,WAKJd,EAAUmJ,EAEV,MAAM8B,GAAmB,QAATL,EAAA7K,SAAS,IAAA6K,OAAA,EAATA,EAAWnE,KAAM,GAC3ByE,GAAe,QAAPL,EAAA7K,SAAO,IAAA6K,OAAA,EAAPA,EAASpE,KAAM,GACvB0E,EAAO,GAAA7K,OAAM2K,EAAO,KAAA3K,OAAI4K,GACxBE,EAAM,GAAA9K,OAAM4K,EAAK,KAAA5K,OAAI2K,GAW3B,GARaxJ,MAAM4J,KACjBlK,SAASC,iBAAiB,kBAC1BkK,QACAvG,GACEA,EAAK4C,eAAejI,EAAM,eAAiByL,GAC3CpG,EAAK4C,eAAejI,EAAM,eAAiB0L,IAGtC7J,OAEP,OADAzB,EAAQsH,SACD,CACL2D,MAAM,EACNrD,QAAS,KACT5G,SAAS,GAKb,MAAMwB,EAAKnD,EAAUuH,eAAe,CAAC1G,IAC/BuE,EAAKpC,EACTvC,EACAC,EACAyC,EACAW,EAAU,QAASnD,IAiBrB,OAfAmE,EAASnE,EAAS,MAAOyE,EAAGnC,EAAGmC,EAAGlC,GAAG,GAGrCqD,EAAYc,IAAI1G,EAAS,UAAWmL,GACpCvF,EAAYc,IAAI1G,EAAS,QAASoL,GAClCxF,EAAYc,IAAI1G,EAAS,SAAUwC,GACnCxC,EAAQyL,eAAe7L,EAAM,eAAgByL,GAC7CrL,EAAQ6D,aAAa,UAAW,GAGhCxE,EAAUqM,eAAe,CAAC1L,IAC1BX,EAAUsM,8BACVhM,EAAgBiM,gBAAgB5L,GAAS6L,WAAU,GAEnD7K,GAAU,EACH,CACLiK,MAAM,EACNrD,QAAS5H,EACTgB,UAEJ,EACA8K,eAAAA,CAAiBjD,GAEf,MAAMjD,EAAcvG,EAAUwG,iBAI9B,IAHmBxG,EAAUqI,gBAGbpG,iBAAiB,iBAAiBG,OAAQ,OAG9B,cAAxBpC,EAAU6J,WACZ7J,EAAUsJ,QAAQ,UAIpB,MAAQjD,MAAOqG,GAAalD,EAG5B,IAAK,MAAMzE,KAAQ2H,EAEb3H,GAAQwB,EAAY4E,IAAIpG,EAAM,YAChCzE,EAAgBiM,gBAAgBxH,GAAMyH,WAAU,GAGhDpI,EAAUoF,EAAKmD,kBAAoBnD,EAAKoD,gBAGxCxI,GAAU,GAKdtB,EAAiB9C,EAAU+C,sBAC7B,EACA8J,cAAAA,CAAgBrD,GAAO,IAADsD,EAEpB,MAAMvG,EAAcvG,EAAUwG,iBAG9B,IAAKzB,GAAQyE,EAAKnD,MAClB,IAAKtB,EAAM,OAGU,QAAjBA,EAAKgI,SAAiC,eAAZhI,EAAKuC,IACjCc,IAIF,MAAM,YAAE4E,EAAW,UAAEC,EAAS,UAAEC,GAAcnI,EAAKmC,WACnD,IAAI8F,GAAeC,GAAaC,KAC9BvM,EAAUoE,EACVwB,EAAYc,IAAItC,EAAM,YAAaoI,QAAQH,IAC3CzG,EAAYc,IAAItC,EAAM,UAAWoI,QAAQD,IAGpB,SAAjBnI,EAAKgI,SAAsBE,GAAW,CACxC,MAAM,GAAEG,EAAE,GAAEC,EAAE,GAAEC,EAAE,GAAEC,EAAE,GAAEjG,GAAOvC,EAAKmC,WAE9BsG,EAAK,GAAArM,QAAOsM,OAAOL,EAAGjG,OAASsG,OAAOJ,EAAGlG,QAAU,EAAC,KAAAhG,QACvDsM,OAAOH,EAAGnG,OAASsG,OAAOF,EAAGpG,QAAU,GAEpCuG,EAAQtN,EAAuB,CACnCmI,QAAS,WACT6B,KAAM,CACJjF,OAAO,GAADhE,OAAKiM,EAAGjG,MAAK,KAAAhG,OAAImM,EAAGnG,MAAK,KAAAhG,OAAIqM,EAAK,KAAArM,OAAIkM,EAAGlG,MAAK,KAAAhG,OAAIoM,EAAGpG,OAC3DmD,OAAQvF,EAAKb,aAAa,UAC1B,eAAgBa,EAAKb,aAAa,gBAClC,aAAc+I,EAAU9F,MACxBsD,KAAM,OACNC,QAAS3F,EAAKb,aAAa,YAAc,KAI7Ca,EAAK4I,sBAAsB,WAAYD,GACvC3I,EAAKkD,SACLjI,EAAU4N,iBACVF,EAAMpG,GAAKA,EAAGH,MACdnH,EAAUqM,eAAe,CAACqB,IAC1B3I,EAAO2I,CACT,CAIF,GAAQ,QAARZ,EAAI/H,SAAI,IAAA+H,GAAJA,EAAMxF,GAAGuG,WAAW,SAAU,CAChC,MAAMC,EAAQ7N,EAAWsG,EAAYS,IAAIjC,EAAM,YAC/CjC,EAAiB,CAACgL,GACpB,MACEhL,EAAiB9C,EAAU+C,sBAE/B,EACAgL,UAAAA,CAAYC,GACV,MAAM/F,EAAS,GAiBf,OAhBA+F,EAAM3H,MAAMiC,SAAQ,SAAUvD,GACxB,iBAAkBA,EAAKqF,OACzBrF,EAAKqF,KAAK,gBAAkBrF,EAAKqF,KAAK,gBACnChD,MAAM,KACN6G,KAAI,SAAUC,GACb,OAAOF,EAAMG,QAAQD,EACvB,IACCE,KAAK,KAIH,MAAMC,KAAKtJ,EAAKqF,KAAK,kBACxBnC,EAAOT,KAAKzC,EAAKqF,KAAK9C,IAG5B,IACO,CAAEW,SACX,EACAqG,qBAAAA,CAAuB9E,GACrB,MAAM+E,EAASvM,SAASiF,eAAe,gBACnCuC,EAAKgF,WAA+B,IAAnBD,EAAOE,SAC1B3O,EAAU4O,cAEZH,EAAOI,SAAWnF,EAAKgF,QACzB,EAEJ,mBC3tBF,IAAIP,EAAM,CACT,UAAW,CACV,KACA,MAED,UAAW,CACV,IACA,KAED,aAAc,CACb,KACA,OAGF,SAASW,EAAoBC,GAC5B,IAAIC,EAAoBC,EAAEd,EAAKY,GAC9B,OAAOG,QAAQC,UAAUC,MAAK,KAC7B,IAAIvF,EAAI,IAAIwF,MAAM,uBAAyBN,EAAM,KAEjD,MADAlF,EAAEyF,KAAO,mBACHzF,CAAC,IAIT,IAAI0F,EAAMpB,EAAIY,GAAMvH,EAAK+H,EAAI,GAC7B,OAAOP,EAAoBnF,EAAE0F,EAAI,IAAIH,MAAK,IAClCJ,EAAoBxH,IAE7B,CACAsH,EAAoBU,KAAO,IAAOC,OAAOD,KAAKrB,GAC9CW,EAAoBtH,GAAK,KACzBkI,EAAOC,QAAUb","sources":["svgedit/editor/extensions/ext-connector/ext-connector.js","svgedit/editor/extensions/ext-connector/locale|lazy|/^/.//.*/.js$/|groupOptions: {}|namespace object"],"sourcesContent":["/**\n * @file ext-connector.js\n *\n * @license MIT\n *\n * @copyright 2010 Alexis Deveria\n * @copyright 2023 Optimistik SAS\n *\n */\n\nconst name = 'connector'\n\nconst loadExtensionTranslation = async function (svgEditor) {\n  let translationModule\n  const lang = svgEditor.configObj.pref('lang')\n  try {\n    translationModule = await import(`./locale/${lang}.js`)\n  } catch (_error) {\n    // eslint-disable-next-line no-console\n    console.warn(`Missing translation (${lang}) for ${name} - using 'en'`)\n    translationModule = await import('./locale/en.js')\n  }\n  svgEditor.i18next.addResourceBundle(lang, name, translationModule.default)\n}\n\nexport default {\n  name,\n  async init (S) {\n    const svgEditor = this\n    const { svgCanvas } = svgEditor\n    const { getElement, $id, $click, addSVGElementsFromJson } = svgCanvas\n    const { svgroot, selectorManager } = S\n    const seNs = svgCanvas.getEditorNS()\n    await loadExtensionTranslation(svgEditor)\n\n    let startX\n    let startY\n    let curLine\n    let startElem\n    let endElem\n\n    let started = false\n    let connections = []\n\n    // Save the original groupSelectedElements method\n    const originalGroupSelectedElements = svgCanvas.groupSelectedElements\n\n    // Override the original groupSelectedElements to exclude connectors\n    svgCanvas.groupSelectedElements = function (...args) {\n      // Remove connectors from selection\n      svgCanvas.removeFromSelection(document.querySelectorAll('[id^=\"conn_\"]'))\n\n      // Call the original method\n      return originalGroupSelectedElements.apply(this, args)\n    }\n\n    // Save the original moveSelectedElements method\n    const originalMoveSelectedElements = svgCanvas.moveSelectedElements\n\n    // Override the original moveSelectedElements to handle connectors\n    svgCanvas.moveSelectedElements = function (...args) {\n      // Call the original method and store its result\n      const cmd = originalMoveSelectedElements.apply(this, args)\n\n      // Update connectors\n      updateConnectors(svgCanvas.getSelectedElements())\n\n      // Return the result of the original method\n      return cmd\n    }\n\n    /**\n     * getBBintersect\n     * @param {Float} x\n     * @param {Float} y\n     * @param {module:utilities.BBoxObject} bb\n     * @param {Float} offset\n     * @returns {module:math.XYObject}\n     */\n    const getBBintersect = (x, y, bb, offset) => {\n      // Adjust bounding box if offset is provided\n      if (offset) {\n        bb = { ...bb } // Create a shallow copy\n        bb.width += offset\n        bb.height += offset\n        bb.x -= offset / 2\n        bb.y -= offset / 2\n      }\n\n      // Calculate center of bounding box\n      const midX = bb.x + bb.width / 2\n      const midY = bb.y + bb.height / 2\n\n      // Calculate lengths from (x, y) to center\n      const lenX = x - midX\n      const lenY = y - midY\n\n      // Calculate slope of line from (x, y) to center\n      const slope = Math.abs(lenY / lenX)\n\n      // Calculate ratio to find intersection point\n      let ratio\n      if (slope < bb.height / bb.width) {\n        ratio = bb.width / 2 / Math.abs(lenX)\n      } else {\n        ratio = lenY ? bb.height / 2 / Math.abs(lenY) : 0\n      }\n\n      // Calculate intersection point\n      return {\n        x: midX + lenX * ratio,\n        y: midY + lenY * ratio\n      }\n    }\n\n    /**\n     * getOffset\n     * @param {\"start\"|\"end\"} side - The side of the line (\"start\" or \"end\") where the marker may be present.\n     * @param {Element} line - The line element to check for a marker.\n     * @returns {Float} - Returns the calculated offset if a marker is present, otherwise returns 0.\n     */\n    const getOffset = (side, line) => {\n      // Check for marker attribute on the given side (\"marker-start\" or \"marker-end\")\n      const hasMarker = line.getAttribute('marker-' + side)\n\n      // Calculate size based on stroke-width, multiplied by a constant factor (here, 5)\n      // TODO: This factor should ideally be based on the actual size of the marker.\n      const size = line.getAttribute('stroke-width') * 5\n\n      // Return calculated size if marker is present, otherwise return 0.\n      return hasMarker ? size : 0\n    }\n\n    /**\n     * showPanel\n     * @param {boolean} on - Determines whether to show or hide the elements.\n     * @returns {void}\n     */\n    const showPanel = on => {\n      // Find the 'connector_rules' or create it if it doesn't exist.\n      let connRules = $id('connector_rules')\n      if (!connRules) {\n        connRules = document.createElement('style')\n        connRules.setAttribute('id', 'connector_rules')\n        document.getElementsByTagName('head')[0].appendChild(connRules)\n      }\n\n      // Update the content of <style> element to either hide or show certain elements.\n      connRules.textContent = !on\n        ? ''\n        : '#tool_clone, #tool_topath, #tool_angle, #xy_panel { display: none !important; }'\n\n      // Update the display property of the <style> element itself based on the 'on' value.\n      if ($id('connector_rules')) {\n        $id('connector_rules').style.display = on ? 'block' : 'none'\n      }\n    }\n\n    /**\n     * setPoint\n     * @param {Element} elem - The SVG element.\n     * @param {Integer|\"end\"} pos - The position index or \"end\".\n     * @param {Float} x - The x-coordinate.\n     * @param {Float} y - The y-coordinate.\n     * @param {boolean} [setMid] - Whether to set the midpoint.\n     * @returns {void}\n     */\n    const setPoint = (elem, pos, x, y, setMid) => {\n      // Create a new SVG point\n      const pts = elem.points\n      const pt = svgroot.createSVGPoint()\n      pt.x = x\n      pt.y = y\n\n      // If position is \"end\", set it to the last index\n      if (pos === 'end') {\n        pos = pts.numberOfItems - 1\n      }\n\n      // Try replacing the point at the specified position\n      pts.replaceItem(pt, pos)\n\n      // Optionally, set the midpoint\n      if (setMid) {\n        const ptStart = pts.getItem(0)\n        const ptEnd = pts.getItem(pts.numberOfItems - 1)\n        setPoint(elem, 1, (ptEnd.x + ptStart.x) / 2, (ptEnd.y + ptStart.y) / 2)\n      }\n    }\n\n    /**\n     * @param {Float} diffX\n     * @param {Float} diffY\n     * @returns {void}\n     */\n    const updatePoints = (line, conn, bb, altBB, pre, altPre) => {\n      const srcX = altBB.x + altBB.width / 2\n      const srcY = altBB.y + altBB.height / 2\n\n      const pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line))\n      setPoint(line, conn.is_start ? 0 : 'end', pt.x, pt.y, true)\n\n      const pt2 = getBBintersect(pt.x, pt.y, altBB, getOffset(altPre, line))\n      setPoint(line, conn.is_start ? 'end' : 0, pt2.x, pt2.y, true)\n    }\n\n    const updateLine = (diffX, diffY) => {\n      const dataStorage = svgCanvas.getDataStorage()\n\n      for (const conn of connections) {\n        const {\n          connector: line,\n          is_start: isStart,\n          start_x: startX,\n          start_y: startY\n        } = conn\n\n        const pre = isStart ? 'start' : 'end'\n        const altPre = isStart ? 'end' : 'start'\n\n        // Update bbox for this element\n        const bb = { ...dataStorage.get(line, `${pre}_bb`) }\n        bb.x = startX + diffX\n        bb.y = startY + diffY\n\n        dataStorage.put(line, `${pre}_bb`, bb)\n\n        // Get center point of connected element\n        const altBB = dataStorage.get(line, `${altPre}_bb`)\n\n        updatePoints(line, conn, bb, altBB, pre, altPre)\n      }\n    }\n\n    // Finds connectors associated with selected elements\n    const findConnectors = (elems = []) => {\n      // Fetch data storage object from svgCanvas\n      const dataStorage = svgCanvas.getDataStorage()\n\n      // Query all connector elements (id startss with conn_)\n      const connectors = document.querySelectorAll('[id^=\"conn_\"]')\n      // Reset connections array\n      connections = []\n\n      // Loop through each connector\n      for (const connector of connectors) {\n        let addThis = false // Flag to indicate whether to add this connector\n        const parts = [] // To hold the starting and ending elements connected by the connector\n\n        // Loop through the connector ends (\"start\" and \"end\")\n        for (const [i, pos] of ['start', 'end'].entries()) {\n          // Fetch connected element and its bounding box\n          let part = dataStorage.get(connector, `c_${pos}`)\n\n          // If part is null or undefined, fetch it and store it\n          if (!part) {\n            part = document.getElementById(\n              connector.attributes['se:connector'].value.split(' ')[i]\n            )\n            dataStorage.put(connector, `c_${pos}`, part.id)\n            dataStorage.put(\n              connector,\n              `${pos}_bb`,\n              svgCanvas.getStrokedBBox([part])\n            )\n          } else {\n            // If part is already stored, fetch it by ID\n            part = document.getElementById(part)\n          }\n\n          // Add the part to the parts array\n          parts.push(part)\n        }\n\n        // Loop through the starting and ending elements connected by the connector\n        for (let i = 0; i < 2; i++) {\n          const cElem = parts[i]\n          const parents = svgCanvas.getParents(cElem?.parentNode)\n\n          // Check if the element is part of a selected group\n          for (const el of parents) {\n            if (elems.includes(el)) {\n              addThis = true\n              break\n            }\n          }\n\n          // If element is missing or parent is null, remove the connector\n          if (!cElem || !cElem.parentNode) {\n            connector.remove()\n            continue\n          }\n\n          // If element is in the selection or part of a selected group\n          if (elems.includes(cElem) || addThis) {\n            const bb = svgCanvas.getStrokedBBox([cElem])\n\n            // Add connection information to the connections array\n            connections.push({\n              elem: cElem,\n              connector,\n              is_start: i === 0,\n              start_x: bb.x,\n              start_y: bb.y\n            })\n          }\n        }\n      }\n    }\n\n    /**\n     * Updates the connectors based on selected elements.\n     * @param {Element[]} [elems] - Optional array of selected elements.\n     * @returns {void}\n     */\n    const updateConnectors = elems => {\n      const dataStorage = svgCanvas.getDataStorage()\n\n      // Find connectors associated with selected elements\n      findConnectors(elems)\n\n      if (connections.length) {\n        // Iterate through each connection to update its state\n        for (const conn of connections) {\n          const {\n            elem,\n            connector: line,\n            is_start: isStart,\n            start_x: startX,\n            start_y: startY\n          } = conn\n\n          // Determine whether the connection starts or ends with this element\n          const pre = isStart ? 'start' : 'end'\n\n          // Update the bounding box for this element\n          const bb = svgCanvas.getStrokedBBox([elem])\n          bb.x = startX\n          bb.y = startY\n          dataStorage.put(line, `${pre}_bb`, bb)\n\n          // Determine the opposite end ('start' or 'end') of the connection\n          const altPre = isStart ? 'end' : 'start'\n\n          // Retrieve the bounding box for the connected element at the opposite end\n          const bb2 = dataStorage.get(line, `${altPre}_bb`)\n\n          // Calculate the center point of the connected element\n          const srcX = bb2?.x + bb2?.width / 2\n          const srcY = bb2?.y + bb2?.height / 2\n\n          // Update the point of the element being moved\n          const pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line))\n          setPoint(line, isStart ? 0 : 'end', pt.x, pt.y, true)\n\n          // Update the point of the connected element at the opposite end\n          const pt2 = getBBintersect(\n            pt.x,\n            pt.y,\n            dataStorage.get(line, `${altPre}_bb`),\n            getOffset(altPre, line)\n          )\n          setPoint(line, isStart ? 'end' : 0, pt2.x, pt2.y, true)\n        }\n      }\n    }\n\n    /**\n     * Do on reset.\n     * @returns {void}\n     */\n    const reset = () => {\n      const dataStorage = svgCanvas.getDataStorage()\n      // Make sure all connectors have data set\n      const svgContent = svgCanvas.getSvgContent()\n      const elements = svgContent.querySelectorAll('*')\n      elements.forEach(element => {\n        const conn = element.getAttributeNS(seNs, 'connector')\n        if (conn) {\n          const connData = conn.split(' ')\n          const sbb = svgCanvas.getStrokedBBox([getElement(connData[0])])\n          const ebb = svgCanvas.getStrokedBBox([getElement(connData[1])])\n          dataStorage.put(element, 'c_start', connData[0])\n          dataStorage.put(element, 'c_end', connData[1])\n          dataStorage.put(element, 'start_bb', sbb)\n          dataStorage.put(element, 'end_bb', ebb)\n          svgCanvas.getEditorNS(true)\n        }\n      })\n    }\n\n    reset()\n\n    return {\n      name: svgEditor.i18next.t(`${name}:name`),\n      callback () {\n        // Add the button and its handler(s)\n        const buttonTemplate = document.createElement('template')\n        const title = `${name}:buttons.0.title`\n        buttonTemplate.innerHTML = `\n         <se-button id=\"tool_connect\" title=\"${title}\" src=\"conn.svg\"></se-button>\n         `\n        $id('tools_left').append(buttonTemplate.content.cloneNode(true))\n        $click($id('tool_connect'), () => {\n          if (this.leftPanel.updateLeftPanel('tool_connect')) {\n            svgCanvas.setMode('connector')\n          }\n        })\n      },\n      mouseDown (opts) {\n        // Retrieve necessary data from the SVG canvas and the event object\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n        const { event: e, start_x: startX, start_y: startY } = opts\n        const mode = svgCanvas.getMode()\n        const {\n          curConfig: { initStroke }\n        } = svgEditor.configObj\n\n        if (mode === 'connector') {\n          // Return if the line is already started\n          if (started) return undefined\n\n          const mouseTarget = e.target\n          const parents = svgCanvas.getParents(mouseTarget.parentNode)\n\n          // Check if the target is a child of the main SVG content\n          if (parents.includes(svgContent)) {\n            // Identify the connectable element, considering foreignObject elements\n            const fo = svgCanvas.getClosest(\n              mouseTarget.parentNode,\n              'foreignObject'\n            )\n            startElem = fo || mouseTarget\n\n            // Retrieve the bounding box and calculate the center of the start element\n            const bb = svgCanvas.getStrokedBBox([startElem])\n            const x = bb.x + bb.width / 2\n            const y = bb.y + bb.height / 2\n\n            // Set the flag to indicate the line has started\n            started = true\n\n            // Create a new polyline element\n            curLine = addSVGElementsFromJson({\n              element: 'polyline',\n              attr: {\n                id: 'conn_' + svgCanvas.getNextId(),\n                points: `${x},${y} ${x},${y} ${startX},${startY}`,\n                stroke: `#${initStroke.color}`,\n                'stroke-width':\n                  !startElem.stroke_width || startElem.stroke_width === 0\n                    ? initStroke.width\n                    : startElem.stroke_width,\n                fill: 'none',\n                opacity: initStroke.opacity,\n                style: 'pointer-events:none'\n              }\n            })\n\n            // Store the bounding box of the start element\n            dataStorage.put(curLine, 'start_bb', bb)\n          }\n\n          return {\n            started: true\n          }\n        }\n\n        if (mode === 'select') {\n          // Find connectors if the mode is 'select'\n          findConnectors(opts.selectedElements)\n        }\n\n        return undefined\n      },\n      mouseMove (opts) {\n        // Exit early if there are no connectors\n        if (connections.length === 0) return\n\n        const dataStorage = svgCanvas.getDataStorage()\n        const zoom = svgCanvas.getZoom()\n        // const e = opts.event;\n        const x = opts.mouse_x / zoom\n        const y = opts.mouse_y / zoom\n        /** @todo  We have a concern if startX or startY are undefined */\n        if (!startX || !startY) return\n\n        const diffX = x - startX\n        const diffY = y - startY\n\n        const mode = svgCanvas.getMode()\n        if (mode === 'connector' && started) {\n          // const sw = curLine.getAttribute('stroke-width') * 3;\n          // Set start point (adjusts based on bb)\n          const pt = getBBintersect(\n            x,\n            y,\n            dataStorage.get(curLine, 'start_bb'),\n            getOffset('start', curLine)\n          )\n          startX = pt.x\n          startY = pt.y\n\n          setPoint(curLine, 0, pt.x, pt.y, true)\n\n          // Set end point\n          setPoint(curLine, 'end', x, y, true)\n        } else if (mode === 'select') {\n          for (const elem of svgCanvas.getSelectedElements()) {\n            if (elem && dataStorage.has(elem, 'c_start')) {\n              svgCanvas.removeFromSelection([elem])\n              elem.transform.baseVal.clear()\n            }\n          }\n          if (connections.length) {\n            updateLine(diffX, diffY)\n          }\n        }\n      },\n      mouseUp (opts) {\n        // Get necessary data and initial setups\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n        const { event: e } = opts\n        let mouseTarget = e.target\n\n        // Early exit if not in connector mode\n        if (svgCanvas.getMode() !== 'connector') return undefined\n\n        // Check for a foreignObject parent and update mouseTarget if found\n        const fo = svgCanvas.getClosest(mouseTarget.parentNode, 'foreignObject')\n        if (fo) mouseTarget = fo\n\n        // Check if the target is a child of the main SVG content\n        const parents = svgCanvas.getParents(mouseTarget.parentNode)\n        const isInSvgContent = parents.includes(svgContent)\n\n        if (mouseTarget === startElem) {\n          // Case: Started drawing line via click\n          started = true\n          return {\n            keep: true,\n            element: null,\n            started\n          }\n        }\n\n        if (!isInSvgContent) {\n          // Case: Invalid target element; remove the line\n          curLine?.remove()\n          started = false\n          return {\n            keep: false,\n            element: null,\n            started\n          }\n        }\n\n        // Valid target element for the end of the line\n        endElem = mouseTarget\n\n        const startId = startElem?.id || ''\n        const endId = endElem?.id || ''\n        const connStr = `${startId} ${endId}`\n        const altStr = `${endId} ${startId}`\n\n        // Prevent duplicate connectors\n        const dupe = Array.from(\n          document.querySelectorAll('[id^=\"conn_\"]')\n        ).filter(\n          conn =>\n            conn.getAttributeNS(seNs, 'connector') === connStr ||\n            conn.getAttributeNS(seNs, 'connector') === altStr\n        )\n\n        if (dupe.length) {\n          curLine.remove()\n          return {\n            keep: false,\n            element: null,\n            started: false\n          }\n        }\n\n        // Update the end point of the connector\n        const bb = svgCanvas.getStrokedBBox([endElem])\n        const pt = getBBintersect(\n          startX,\n          startY,\n          bb,\n          getOffset('start', curLine)\n        )\n        setPoint(curLine, 'end', pt.x, pt.y, true)\n\n        // Save metadata to the connector\n        dataStorage.put(curLine, 'c_start', startId)\n        dataStorage.put(curLine, 'c_end', endId)\n        dataStorage.put(curLine, 'end_bb', bb)\n        curLine.setAttributeNS(seNs, 'se:connector', connStr)\n        curLine.setAttribute('opacity', 1)\n\n        // Finalize the connector\n        svgCanvas.addToSelection([curLine])\n        svgCanvas.moveToBottomSelectedElement()\n        selectorManager.requestSelector(curLine).showGrips(false)\n\n        started = false\n        return {\n          keep: true,\n          element: curLine,\n          started\n        }\n      },\n      selectedChanged (opts) {\n        // Get necessary data storage and SVG content\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n\n        // Exit early if there are no connectors\n        if (!svgContent.querySelectorAll('[id^=\"conn_\"]').length) return\n\n        // If the current mode is 'connector', switch to 'select'\n        if (svgCanvas.getMode() === 'connector') {\n          svgCanvas.setMode('select')\n        }\n\n        // Get currently selected elements\n        const { elems: selElems } = opts\n\n        // Iterate through selected elements\n        for (const elem of selElems) {\n          // If the element has a connector start, handle it\n          if (elem && dataStorage.has(elem, 'c_start')) {\n            selectorManager.requestSelector(elem).showGrips(false)\n\n            // Show panel depending on selection state\n            showPanel(opts.selectedElement && !opts.multiselected)\n          } else {\n            // Hide panel if no connector start\n            showPanel(false)\n          }\n        }\n\n        // Update connectors based on selected elements\n        updateConnectors(svgCanvas.getSelectedElements())\n      },\n      elementChanged (opts) {\n        // Get the necessary data storage\n        const dataStorage = svgCanvas.getDataStorage()\n\n        // Get the first element from the options; exit early if it's null\n        let [elem] = opts.elems\n        if (!elem) return\n\n        // Reinitialize if it's the main SVG content\n        if (elem.tagName === 'svg' && elem.id === 'svgcontent') {\n          reset()\n        }\n\n        // Check for marker attributes and update offsets\n        const { markerStart, markerMid, markerEnd } = elem.attributes\n        if (markerStart || markerMid || markerEnd) {\n          curLine = elem\n          dataStorage.put(elem, 'start_off', Boolean(markerStart))\n          dataStorage.put(elem, 'end_off', Boolean(markerEnd))\n\n          // Convert lines to polyline if there's a mid-marker\n          if (elem.tagName === 'line' && markerMid) {\n            const { x1, x2, y1, y2, id } = elem.attributes\n\n            const midPt = `${(Number(x1.value) + Number(x2.value)) / 2},${\n              (Number(y1.value) + Number(y2.value)) / 2\n            }`\n            const pline = addSVGElementsFromJson({\n              element: 'polyline',\n              attr: {\n                points: `${x1.value},${y1.value} ${midPt} ${x2.value},${y2.value}`,\n                stroke: elem.getAttribute('stroke'),\n                'stroke-width': elem.getAttribute('stroke-width'),\n                'marker-mid': markerMid.value,\n                fill: 'none',\n                opacity: elem.getAttribute('opacity') || 1\n              }\n            })\n\n            elem.insertAdjacentElement('afterend', pline)\n            elem.remove()\n            svgCanvas.clearSelection()\n            pline.id = id.value\n            svgCanvas.addToSelection([pline])\n            elem = pline\n          }\n        }\n\n        // Update connectors based on the current element\n        if (elem?.id.startsWith('conn_')) {\n          const start = getElement(dataStorage.get(elem, 'c_start'))\n          updateConnectors([start])\n        } else {\n          updateConnectors(svgCanvas.getSelectedElements())\n        }\n      },\n      IDsUpdated (input) {\n        const remove = []\n        input.elems.forEach(function (elem) {\n          if ('se:connector' in elem.attr) {\n            elem.attr['se:connector'] = elem.attr['se:connector']\n              .split(' ')\n              .map(function (oldID) {\n                return input.changes[oldID]\n              })\n              .join(' ')\n\n            // Check validity - the field would be something like 'svg_21 svg_22', but\n            // if one end is missing, it would be 'svg_21' and therefore fail this test\n            if (!/. ./.test(elem.attr['se:connector'])) {\n              remove.push(elem.attr.id)\n            }\n          }\n        })\n        return { remove }\n      },\n      toolButtonStateUpdate (opts) {\n        const button = document.getElementById('tool_connect')\n        if (opts.nostroke && button.pressed === true) {\n          svgEditor.clickSelect()\n        }\n        button.disabled = opts.nostroke\n      }\n    }\n  }\n}\n","var map = {\n\t\"./en.js\": [\n\t\t8363,\n\t\t8363\n\t],\n\t\"./fr.js\": [\n\t\t561,\n\t\t561\n\t],\n\t\"./zh-CN.js\": [\n\t\t1924,\n\t\t1979\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = 2281;\nmodule.exports = webpackAsyncContext;"],"names":["name","init","S","svgEditor","this","svgCanvas","getElement","$id","$click","addSVGElementsFromJson","svgroot","selectorManager","seNs","getEditorNS","startX","startY","curLine","startElem","endElem","async","translationModule","lang","configObj","pref","concat","_error","console","warn","i18next","addResourceBundle","default","loadExtensionTranslation","started","connections","originalGroupSelectedElements","groupSelectedElements","removeFromSelection","document","querySelectorAll","_len","arguments","length","args","Array","_key","apply","originalMoveSelectedElements","moveSelectedElements","_len2","_key2","cmd","updateConnectors","getSelectedElements","getBBintersect","x","y","bb","offset","width","height","midX","midY","lenX","lenY","ratio","Math","abs","getOffset","side","line","hasMarker","getAttribute","size","showPanel","on","connRules","createElement","setAttribute","getElementsByTagName","appendChild","textContent","style","display","setPoint","elem","pos","setMid","pts","points","pt","createSVGPoint","numberOfItems","replaceItem","ptStart","getItem","ptEnd","updatePoints","conn","altBB","pre","altPre","srcX","srcY","is_start","pt2","findConnectors","elems","undefined","dataStorage","getDataStorage","connectors","connector","addThis","parts","i","entries","part","get","getElementById","attributes","value","split","put","id","getStrokedBBox","push","cElem","parents","getParents","parentNode","el","includes","start_x","start_y","remove","isStart","bb2","reset","getSvgContent","forEach","element","getAttributeNS","connData","sbb","ebb","t","callback","buttonTemplate","title","innerHTML","append","content","cloneNode","leftPanel","updateLeftPanel","setMode","mouseDown","opts","svgContent","event","e","mode","getMode","curConfig","initStroke","mouseTarget","target","fo","getClosest","attr","getNextId","stroke","color","stroke_width","fill","opacity","selectedElements","mouseMove","zoom","getZoom","mouse_x","mouse_y","diffX","diffY","has","transform","baseVal","clear","updateLine","mouseUp","_startElem","_endElem","isInSvgContent","keep","_curLine","startId","endId","connStr","altStr","from","filter","setAttributeNS","addToSelection","moveToBottomSelectedElement","requestSelector","showGrips","selectedChanged","selElems","selectedElement","multiselected","elementChanged","_elem","tagName","markerStart","markerMid","markerEnd","Boolean","x1","x2","y1","y2","midPt","Number","pline","insertAdjacentElement","clearSelection","startsWith","start","IDsUpdated","input","map","oldID","changes","join","test","toolButtonStateUpdate","button","nostroke","pressed","clickSelect","disabled","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","Error","code","ids","keys","Object","module","exports"],"sourceRoot":""}